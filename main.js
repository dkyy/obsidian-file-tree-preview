/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// main.ts
var main_exports = {};
__export(main_exports, {
  default: () => FileTreePreviewPlugin
});
module.exports = __toCommonJS(main_exports);
var import_obsidian = require("obsidian");
var VIEW_TYPE_FILE_TREE_PREVIEW = "file-tree-preview-view";
var DEFAULT_DATA = {
  collapsedFolders: [],
  sortOrder: "name-asc",
  treeWidth: 300,
  previewLines: 4,
  removeLinkBrackets: true,
  activeOnLaunch: false,
  compactMode: false,
  useAccentColor: true,
  showHoverEffect: false,
  folderIconStyle: "custom"
};
var FileTreePreviewPlugin = class extends import_obsidian.Plugin {
  async onload() {
    await this.loadPluginData();
    this.registerView(
      VIEW_TYPE_FILE_TREE_PREVIEW,
      (leaf) => new FileTreePreviewView(leaf, this)
    );
    this.addRibbonIcon("folder-tree", "File Tree Preview", () => {
      this.activateView().catch(console.error);
    });
    this.addCommand({
      id: "open",
      name: "Open",
      callback: () => {
        this.activateView().catch(console.error);
      }
    });
    this.addSettingTab(new FileTreePreviewSettingTab(this.app, this));
    if (this.data.activeOnLaunch) {
      this.app.workspace.onLayoutReady(() => {
        this.activateView().catch(console.error);
      });
    }
  }
  onunload() {
  }
  async loadPluginData() {
    const loadedData = await super.loadData();
    this.data = Object.assign({}, DEFAULT_DATA, loadedData);
    if (loadedData && "showFolderIcons" in loadedData) {
      this.data.folderIconStyle = loadedData.showFolderIcons ? "folder" : "none";
      await this.savePluginData();
    }
  }
  async savePluginData() {
    await super.saveData(this.data);
  }
  async activateView() {
    const { workspace } = this.app;
    let leaf = null;
    const leaves = workspace.getLeavesOfType(VIEW_TYPE_FILE_TREE_PREVIEW);
    if (leaves.length > 0) {
      leaf = leaves[0];
    } else {
      leaf = workspace.getLeftLeaf(false);
      await (leaf == null ? void 0 : leaf.setViewState({ type: VIEW_TYPE_FILE_TREE_PREVIEW, active: true }));
    }
    if (leaf) {
      workspace.revealLeaf(leaf);
    }
  }
};
var FileTreePreviewView = class extends import_obsidian.ItemView {
  constructor(leaf, plugin) {
    super(leaf);
    this.selectedFolder = null;
    this.activeFile = null;
    this.isResizing = false;
    this.previewsCollapsed = false;
    this.iconizeDataCache = "";
    this.dragGhost = null;
    this.isRenderingTree = false;
    this.plugin = plugin;
    this.collapsedFolders = new Set(plugin.data.collapsedFolders);
  }
  getViewType() {
    return VIEW_TYPE_FILE_TREE_PREVIEW;
  }
  getDisplayText() {
    return "File Tree Preview";
  }
  getIcon() {
    return "folder-tree";
  }
  async onOpen() {
    const container = this.containerEl.children[1];
    container.empty();
    container.addClass("file-tree-preview-container");
    await this.waitForIconizePlugin();
    this.mainLayout = container.createDiv({ cls: "ftp-main-layout" });
    if (this.plugin.data.compactMode) {
      this.mainLayout.addClass("ftp-compact");
    }
    if (!this.plugin.data.useAccentColor) {
      this.mainLayout.addClass("ftp-neutral-highlight");
    }
    const isTouchDevice = "ontouchstart" in window || navigator.maxTouchPoints > 0;
    if (this.plugin.data.showHoverEffect && !isTouchDevice) {
      this.mainLayout.addClass("ftp-show-hover");
    }
    this.treeContainer = this.mainLayout.createDiv({ cls: "ftp-tree-column" });
    if (isTouchDevice) {
      this.treeContainer.addClass("ftp-touch-equal");
    } else {
      this.treeContainer.setCssProps({ width: `${this.plugin.data.treeWidth}px` });
    }
    this.resizeHandle = this.mainLayout.createDiv({ cls: "ftp-resize-handle" });
    if (!isTouchDevice) {
      this.setupResizeHandle();
    } else {
      this.resizeHandle.addClass("ftp-hidden");
    }
    this.previewContainer = this.mainLayout.createDiv({ cls: "ftp-preview-column" });
    this.previewHeader = this.previewContainer.createDiv({ cls: "ftp-preview-header" });
    this.previewContent = this.previewContainer.createDiv({ cls: "ftp-preview-content" });
    await this.renderFileTree();
    await this.renderPreview();
    this.register(() => {
      const timeoutId = window.setTimeout(() => {
        this.renderFileTree().catch(console.error);
      }, 1e3);
      return () => window.clearTimeout(timeoutId);
    });
    this.registerEvent(
      this.app.vault.on("create", () => {
        this.renderFileTree().catch(console.error);
      })
    );
    this.registerEvent(
      this.app.vault.on("delete", () => {
        this.renderFileTree().catch(console.error);
      })
    );
    this.registerEvent(
      this.app.vault.on("rename", () => {
        this.renderFileTree().catch(console.error);
        this.renderPreview().catch(console.error);
      })
    );
    this.registerEvent(
      this.app.workspace.on("file-open", (file) => {
        if (file && file.parent) {
          const previousFolder = this.selectedFolder;
          this.activeFile = file;
          this.selectedFolder = file.parent;
          if (previousFolder === this.selectedFolder) {
            this.updateActiveHighlight();
          } else {
            Promise.all([
              this.renderFileTree(),
              this.renderPreview()
            ]).catch(console.error);
          }
        }
      })
    );
    this.startIconizeDataPolling();
  }
  async onClose() {
  }
  async waitForIconizePlugin() {
    var _a, _b;
    const maxWaitTime = 5e3;
    const checkInterval = 100;
    let waited = 0;
    while (waited < maxWaitTime) {
      const iconFolderPlugin = (_b = (_a = this.app.plugins) == null ? void 0 : _a.plugins) == null ? void 0 : _b["obsidian-icon-folder"];
      if ((iconFolderPlugin == null ? void 0 : iconFolderPlugin.data) && (iconFolderPlugin == null ? void 0 : iconFolderPlugin.api)) {
        return;
      }
      await new Promise((resolve) => setTimeout(resolve, checkInterval));
      waited += checkInterval;
    }
  }
  startIconizeDataPolling() {
    const intervalId = window.setInterval(() => {
      var _a, _b;
      try {
        const iconFolderPlugin = (_b = (_a = this.app.plugins) == null ? void 0 : _a.plugins) == null ? void 0 : _b["obsidian-icon-folder"];
        if (iconFolderPlugin == null ? void 0 : iconFolderPlugin.data) {
          const currentData = JSON.stringify(
            Object.entries(iconFolderPlugin.data).filter(([key]) => key !== "settings").sort()
          );
          if (this.iconizeDataCache && currentData !== this.iconizeDataCache) {
            this.iconizeDataCache = currentData;
            this.renderFileTree().catch(console.error);
          } else if (!this.iconizeDataCache) {
            this.iconizeDataCache = currentData;
          }
        }
      } catch (e) {
      }
    }, 500);
    this.register(() => window.clearInterval(intervalId));
  }
  setCompactMode(enabled) {
    if (enabled) {
      this.mainLayout.addClass("ftp-compact");
    } else {
      this.mainLayout.removeClass("ftp-compact");
    }
  }
  setHighlightColor(useAccent) {
    if (useAccent) {
      this.mainLayout.removeClass("ftp-neutral-highlight");
    } else {
      this.mainLayout.addClass("ftp-neutral-highlight");
    }
  }
  setHoverEffect(enabled) {
    if (enabled) {
      this.mainLayout.addClass("ftp-show-hover");
    } else {
      this.mainLayout.removeClass("ftp-show-hover");
    }
  }
  updateActiveHighlight() {
    const allCards = this.previewContent.querySelectorAll(".ftp-preview-item");
    allCards.forEach((card) => {
      var _a, _b;
      const htmlCard = card;
      const filename = (_a = card.querySelector(".ftp-preview-filename strong")) == null ? void 0 : _a.textContent;
      if (filename === ((_b = this.activeFile) == null ? void 0 : _b.basename)) {
        htmlCard.addClass("ftp-preview-item-active");
      } else {
        htmlCard.removeClass("ftp-preview-item-active");
      }
    });
  }
  getFolderIcon(folder) {
    var _a, _b;
    try {
      const iconFolderPlugin = (_b = (_a = this.app.plugins) == null ? void 0 : _a.plugins) == null ? void 0 : _b["obsidian-icon-folder"];
      if (iconFolderPlugin) {
        const iconData = iconFolderPlugin.data;
        if (iconData && iconData[folder.path]) {
          const iconValue = iconData[folder.path];
          if (/[\p{Emoji}]/u.test(iconValue)) {
            return { type: "emoji", value: iconValue };
          } else {
            return { type: "icon", value: iconValue };
          }
        }
      }
    } catch (e) {
    }
    return null;
  }
  isDescendantOf(possibleDescendant, possibleAncestor) {
    let current = possibleDescendant;
    while (current) {
      if (current === possibleAncestor) {
        return true;
      }
      current = current.parent;
    }
    return false;
  }
  setupResizeHandle() {
    const handleMouseDown = (e) => {
      this.isResizing = true;
      e.preventDefault();
      document.body.setCssProps({ cursor: "col-resize" });
    };
    const handleMouseMove = (e) => {
      if (!this.isResizing)
        return;
      const containerRect = this.mainLayout.getBoundingClientRect();
      const newWidth = e.clientX - containerRect.left;
      const minWidth = 150;
      const maxWidth = containerRect.width * 0.8;
      const clampedWidth = Math.max(minWidth, Math.min(newWidth, maxWidth));
      this.treeContainer.setCssProps({ width: `${clampedWidth}px` });
      this.plugin.data.treeWidth = clampedWidth;
    };
    const handleMouseUp = () => {
      if (this.isResizing) {
        this.isResizing = false;
        document.body.setCssProps({ cursor: "" });
        this.plugin.savePluginData().catch(console.error);
      }
    };
    this.resizeHandle.addEventListener("mousedown", handleMouseDown);
    document.addEventListener("mousemove", handleMouseMove);
    document.addEventListener("mouseup", handleMouseUp);
    this.register(() => {
      document.removeEventListener("mousemove", handleMouseMove);
      document.removeEventListener("mouseup", handleMouseUp);
    });
  }
  async renderFileTree() {
    if (this.isRenderingTree) {
      return;
    }
    this.isRenderingTree = true;
    try {
      this.treeContainer.empty();
      const root = this.app.vault.getRoot();
      await this.renderFolder(root, this.treeContainer, 0);
    } finally {
      this.isRenderingTree = false;
    }
  }
  async renderFolder(folder, container, level) {
    var _a, _b, _c;
    const folders = folder.children.filter((item) => item instanceof import_obsidian.TFolder).sort((a, b) => a.name.localeCompare(b.name));
    for (const item of folders) {
      const isSelected = this.selectedFolder === item;
      const hasSubfolders = item.children.some((child) => child instanceof import_obsidian.TFolder);
      const isCollapsed = this.collapsedFolders.has(item.path);
      const folderEl = container.createDiv({ cls: "ftp-folder-item" });
      folderEl.setCssProps({ paddingLeft: `calc(var(--ftp-folder-indent) * ${level})` });
      const folderHeader = folderEl.createDiv({
        cls: "ftp-folder-header" + (isSelected ? " ftp-selected" : "")
      });
      if (hasSubfolders) {
        const caret = folderHeader.createSpan({ cls: "ftp-folder-caret" });
        (0, import_obsidian.setIcon)(caret, "right-triangle");
        if (isCollapsed) {
          caret.addClass("ftp-collapsed");
        }
        caret.addEventListener("click", (e) => {
          e.stopPropagation();
          const willBeCollapsed = !folderContent.hasClass("ftp-collapsed");
          folderContent.toggleClass("ftp-collapsed", willBeCollapsed);
          caret.toggleClass("ftp-collapsed", willBeCollapsed);
          if (willBeCollapsed) {
            this.collapsedFolders.add(item.path);
          } else {
            this.collapsedFolders.delete(item.path);
          }
          this.plugin.data.collapsedFolders = Array.from(this.collapsedFolders);
          this.plugin.savePluginData().catch(console.error);
        });
      } else {
        folderHeader.createSpan({ cls: "ftp-folder-caret-spacer" });
      }
      const iconStyle = this.plugin.data.folderIconStyle;
      const folderNameSpan = folderHeader.createSpan({ cls: "ftp-folder-name" });
      if (iconStyle === "none") {
        folderNameSpan.setText(item.name);
      } else if (iconStyle === "custom") {
        const customIcon = this.getFolderIcon(item);
        const defaultIcon = hasSubfolders ? "LiFolders" : "TiFolder";
        const iconToRender = customIcon ? customIcon.value : defaultIcon;
        if ((customIcon == null ? void 0 : customIcon.type) === "emoji") {
          folderNameSpan.setText(customIcon.value + " " + item.name);
        } else {
          try {
            const iconFolderPlugin = (_b = (_a = this.app.plugins) == null ? void 0 : _a.plugins) == null ? void 0 : _b["obsidian-icon-folder"];
            if ((_c = iconFolderPlugin == null ? void 0 : iconFolderPlugin.api) == null ? void 0 : _c.getIconByName) {
              const iconData = iconFolderPlugin.api.getIconByName(iconToRender);
              if (iconData && iconData.svgElement) {
                const iconContainer = folderNameSpan.createSpan({ cls: "ftp-icon-container" });
                const parser = new DOMParser();
                const doc = parser.parseFromString(iconData.svgElement, "image/svg+xml");
                const svgEl = doc.documentElement;
                if (svgEl && !svgEl.querySelector("parsererror")) {
                  iconContainer.appendChild(svgEl);
                }
                folderNameSpan.appendText(" " + item.name);
              } else {
                const fallbackIcon = iconFolderPlugin.api.getIconByName(defaultIcon);
                if (fallbackIcon && fallbackIcon.svgElement) {
                  const iconContainer = folderNameSpan.createSpan({ cls: "ftp-icon-container" });
                  const parser = new DOMParser();
                  const doc = parser.parseFromString(fallbackIcon.svgElement, "image/svg+xml");
                  const svgEl = doc.documentElement;
                  if (svgEl && !svgEl.querySelector("parsererror")) {
                    iconContainer.appendChild(svgEl);
                  }
                  folderNameSpan.appendText(" " + item.name);
                } else {
                  folderNameSpan.setText(item.name);
                }
              }
            } else {
              folderNameSpan.setText(item.name);
            }
          } catch (error) {
            console.error("Error rendering icon:", error);
            folderNameSpan.setText(item.name);
          }
        }
      } else if (iconStyle === "folder") {
        folderNameSpan.setText("\u{1F4C1} " + item.name);
      }
      const folderContent = container.createDiv({ cls: "ftp-folder-content" });
      if (isCollapsed) {
        folderContent.addClass("ftp-collapsed");
      }
      folderHeader.setAttribute("draggable", "true");
      folderHeader.addEventListener("dragstart", (e) => {
        var _a2, _b2;
        e.stopPropagation();
        (_a2 = e.dataTransfer) == null ? void 0 : _a2.setData("text/plain", item.path);
        (_b2 = e.dataTransfer) == null ? void 0 : _b2.setData("application/x-obsidian-folder", "true");
        if (e.dataTransfer) {
          e.dataTransfer.effectAllowed = "move";
        }
        this.dragGhost = document.body.createDiv({ cls: "ftp-drag-ghost" });
        this.dragGhost.setText(item.name);
        const accentColor = getComputedStyle(document.body).getPropertyValue("--interactive-accent").trim();
        this.dragGhost.setCssProps({
          position: "fixed",
          left: "-9999px",
          top: "0",
          backgroundColor: `color-mix(in srgb, ${accentColor} 50%, transparent)`,
          color: getComputedStyle(document.body).getPropertyValue("--text-on-accent").trim()
        });
        if (e.dataTransfer) {
          e.dataTransfer.setDragImage(this.dragGhost, 50, 15);
        }
        folderHeader.addClass("ftp-dragging");
      });
      folderHeader.addEventListener("dragend", () => {
        folderHeader.removeClass("ftp-dragging");
        if (this.dragGhost) {
          this.dragGhost.remove();
          this.dragGhost = null;
        }
      });
      folderHeader.addEventListener("click", () => {
        this.selectedFolder = item;
        Promise.all([
          this.renderFileTree(),
          this.renderPreview()
        ]).catch(console.error);
      });
      folderHeader.addEventListener("contextmenu", (e) => {
        e.preventDefault();
        const menu = new import_obsidian.Menu();
        menu.addItem((menuItem) => {
          menuItem.setTitle("New file").setIcon("document").onClick(() => {
            const createFile = async () => {
              const fileName = "Untitled.md";
              let filePath = `${item.path}/${fileName}`;
              let counter = 1;
              while (await this.app.vault.adapter.exists(filePath)) {
                filePath = `${item.path}/Untitled ${counter}.md`;
                counter++;
              }
              const file = await this.app.vault.create(filePath, "");
              await this.app.workspace.getLeaf(false).openFile(file);
            };
            createFile().catch(console.error);
          });
        });
        menu.addItem((menuItem) => {
          menuItem.setTitle("New folder").setIcon("folder").onClick(() => {
            const createFolder = async () => {
              const folderName = "New folder";
              let folderPath = `${item.path}/${folderName}`;
              let counter = 1;
              while (await this.app.vault.adapter.exists(folderPath)) {
                folderPath = `${item.path}/New folder ${counter}`;
                counter++;
              }
              await this.app.vault.createFolder(folderPath);
            };
            createFolder().catch(console.error);
          });
        });
        menu.addSeparator();
        menu.addItem((menuItem) => {
          menuItem.setTitle("Rename").setIcon("pencil").onClick(() => {
            new RenameModal(this.app, item.name, (newName) => {
              const renameFolder = async () => {
                if (newName !== item.name) {
                  const parentPath = item.parent ? item.parent.path : "";
                  const newPath = parentPath ? `${parentPath}/${newName}` : newName;
                  try {
                    await this.app.vault.rename(item, newPath);
                  } catch (error) {
                    console.error("Failed to rename folder:", error);
                  }
                }
              };
              renameFolder().catch(console.error);
            }).open();
          });
        });
        menu.addItem((menuItem) => {
          menuItem.setTitle("Delete").setIcon("trash").onClick(() => {
            new DeleteFolderModal(this.app, item.name, () => {
              const deleteFolder = async () => {
                try {
                  await this.app.fileManager.trashFile(item);
                } catch (error) {
                  console.error("Failed to delete folder:", error);
                  new import_obsidian.Notice("Failed to delete folder");
                }
              };
              deleteFolder().catch(console.error);
            }).open();
          });
        });
        menu.addSeparator();
        this.app.workspace.trigger("file-menu", menu, item, "file-explorer");
        menu.showAtMouseEvent(e);
      });
      folderHeader.addEventListener("dragover", (e) => {
        e.preventDefault();
        e.stopPropagation();
        if (e.dataTransfer) {
          e.dataTransfer.dropEffect = "move";
        }
        folderHeader.addClass("ftp-drop-target");
      });
      folderHeader.addEventListener("dragleave", (e) => {
        e.preventDefault();
        e.stopPropagation();
        folderHeader.removeClass("ftp-drop-target");
      });
      folderHeader.addEventListener("drop", (e) => {
        var _a2, _b2;
        e.preventDefault();
        e.stopPropagation();
        folderHeader.removeClass("ftp-drop-target");
        const draggedPath = (_a2 = e.dataTransfer) == null ? void 0 : _a2.getData("text/plain");
        if (!draggedPath)
          return;
        const draggedItem = this.app.vault.getAbstractFileByPath(draggedPath);
        if (!draggedItem)
          return;
        const isFolder = ((_b2 = e.dataTransfer) == null ? void 0 : _b2.getData("application/x-obsidian-folder")) === "true";
        const handleDrop = async () => {
          if (isFolder && draggedItem instanceof import_obsidian.TFolder) {
            if (draggedItem === item) {
              new import_obsidian.Notice("Cannot move a folder into itself");
              return;
            }
            if (this.isDescendantOf(item, draggedItem)) {
              new import_obsidian.Notice("Cannot move a folder into one of its subfolders");
              return;
            }
            if (draggedItem.parent === item) {
              new import_obsidian.Notice("Folder is already in this location");
              return;
            }
            const newPath = `${item.path}/${draggedItem.name}`;
            try {
              await this.app.vault.rename(draggedItem, newPath);
            } catch (error) {
              console.error("Failed to move folder:", error);
              new import_obsidian.Notice("Failed to move folder");
            }
          } else if (draggedItem instanceof import_obsidian.TFile) {
            if (draggedItem.parent === item) {
              return;
            }
            const newPath = `${item.path}/${draggedItem.name}`;
            try {
              await this.app.vault.rename(draggedItem, newPath);
            } catch (error) {
              console.error("Failed to move file:", error);
              new import_obsidian.Notice("Failed to move file");
            }
          }
        };
        handleDrop().catch(console.error);
      });
      await this.renderFolder(item, folderContent, level + 1);
    }
  }
  async renderPreview() {
    this.previewHeader.empty();
    this.previewContent.empty();
    if (!this.selectedFolder) {
      this.previewHeader.setText("");
      this.previewContent.createDiv({
        text: "Select a folder to preview its files",
        cls: "ftp-no-selection"
      });
      return;
    }
    const headerLeft = this.previewHeader.createDiv({ cls: "ftp-preview-header-left" });
    headerLeft.setText(this.selectedFolder.name);
    const headerRight = this.previewHeader.createDiv({ cls: "ftp-preview-header-right" });
    const sortButton = headerRight.createEl("button", {
      cls: "ftp-header-button",
      attr: { "aria-label": "Sort files" }
    });
    sortButton.setText("\u21C5");
    sortButton.addEventListener("click", (e) => {
      const menu = new import_obsidian.Menu();
      menu.addItem((item) => {
        item.setTitle("Name (A to Z)").setChecked(this.plugin.data.sortOrder === "name-asc").onClick(() => {
          const updateSort = async () => {
            this.plugin.data.sortOrder = "name-asc";
            await this.plugin.savePluginData();
            await this.renderPreview();
          };
          updateSort().catch(console.error);
        });
      });
      menu.addItem((item) => {
        item.setTitle("Name (Z to A)").setChecked(this.plugin.data.sortOrder === "name-desc").onClick(() => {
          const updateSort = async () => {
            this.plugin.data.sortOrder = "name-desc";
            await this.plugin.savePluginData();
            await this.renderPreview();
          };
          updateSort().catch(console.error);
        });
      });
      menu.addSeparator();
      menu.addItem((item) => {
        item.setTitle("Modified (newest first)").setChecked(this.plugin.data.sortOrder === "modified-new").onClick(() => {
          const updateSort = async () => {
            this.plugin.data.sortOrder = "modified-new";
            await this.plugin.savePluginData();
            await this.renderPreview();
          };
          updateSort().catch(console.error);
        });
      });
      menu.addItem((item) => {
        item.setTitle("Modified (oldest first)").setChecked(this.plugin.data.sortOrder === "modified-old").onClick(() => {
          const updateSort = async () => {
            this.plugin.data.sortOrder = "modified-old";
            await this.plugin.savePluginData();
            await this.renderPreview();
          };
          updateSort().catch(console.error);
        });
      });
      menu.addSeparator();
      menu.addItem((item) => {
        item.setTitle("Created (newest first)").setChecked(this.plugin.data.sortOrder === "created-new").onClick(() => {
          const updateSort = async () => {
            this.plugin.data.sortOrder = "created-new";
            await this.plugin.savePluginData();
            await this.renderPreview();
          };
          updateSort().catch(console.error);
        });
      });
      menu.addItem((item) => {
        item.setTitle("Created (oldest first)").setChecked(this.plugin.data.sortOrder === "created-old").onClick(() => {
          const updateSort = async () => {
            this.plugin.data.sortOrder = "created-old";
            await this.plugin.savePluginData();
            await this.renderPreview();
          };
          updateSort().catch(console.error);
        });
      });
      menu.showAtMouseEvent(e);
    });
    const collapseButton = headerRight.createEl("button", {
      cls: "ftp-header-button",
      attr: { "aria-label": "Collapse previews" }
    });
    collapseButton.setText(this.previewsCollapsed ? "\u2295" : "\u2296");
    collapseButton.addEventListener("click", () => {
      this.previewsCollapsed = !this.previewsCollapsed;
      collapseButton.setText(this.previewsCollapsed ? "\u2295" : "\u2296");
      collapseButton.setAttribute("aria-label", this.previewsCollapsed ? "Expand previews" : "Collapse previews");
      if (this.previewsCollapsed) {
        this.previewContent.addClass("ftp-previews-collapsed");
      } else {
        this.previewContent.removeClass("ftp-previews-collapsed");
      }
    });
    const newFileButton = headerRight.createEl("button", {
      cls: "ftp-header-button",
      attr: { "aria-label": "New file" }
    });
    newFileButton.setText("+");
    newFileButton.addEventListener("click", () => {
      if (this.selectedFolder) {
        const createFile = async () => {
          try {
            const fileName = "Untitled.md";
            let filePath = `${this.selectedFolder.path}/${fileName}`;
            let counter = 1;
            while (await this.app.vault.adapter.exists(filePath)) {
              filePath = `${this.selectedFolder.path}/Untitled ${counter}.md`;
              counter++;
            }
            const file = await this.app.vault.create(filePath, "");
            await this.app.workspace.getLeaf(false).openFile(file);
          } catch (error) {
            console.error("Error creating new file:", error);
            new import_obsidian.Notice("Failed to create new file");
          }
        };
        createFile().catch(console.error);
      }
    });
    const files = this.selectedFolder.children.filter(
      (child) => child instanceof import_obsidian.TFile
    );
    if (files.length === 0) {
      this.previewContent.createDiv({
        text: "This folder contains no files",
        cls: "ftp-no-selection"
      });
      return;
    }
    this.sortFiles(files);
    for (const file of files) {
      await this.renderFilePreview(file);
    }
  }
  sortFiles(files) {
    switch (this.plugin.data.sortOrder) {
      case "name-asc":
        files.sort((a, b) => a.basename.localeCompare(b.basename));
        break;
      case "name-desc":
        files.sort((a, b) => b.basename.localeCompare(a.basename));
        break;
      case "modified-new":
        files.sort((a, b) => b.stat.mtime - a.stat.mtime);
        break;
      case "modified-old":
        files.sort((a, b) => a.stat.mtime - b.stat.mtime);
        break;
      case "created-new":
        files.sort((a, b) => b.stat.ctime - a.stat.ctime);
        break;
      case "created-old":
        files.sort((a, b) => a.stat.ctime - b.stat.ctime);
        break;
    }
  }
  getFileTypeInfo(file) {
    const ext = file.extension.toLowerCase();
    if (["png", "jpg", "jpeg", "gif", "svg", "webp", "bmp"].includes(ext)) {
      return { type: "image", icon: "", label: "" };
    }
    if (ext === "canvas") {
      return {
        type: "placeholder",
        icon: `<svg viewBox="0 0 100 100" class="ftp-file-icon"><rect x="10" y="10" width="30" height="30" fill="currentColor" opacity="0.3"/><rect x="50" y="10" width="40" height="20" fill="currentColor" opacity="0.3"/><rect x="10" y="50" width="40" height="20" fill="currentColor" opacity="0.3"/><rect x="60" y="50" width="30" height="30" fill="currentColor" opacity="0.3"/></svg>`,
        label: "Canvas"
      };
    }
    if (ext === "excalidraw" || file.basename.endsWith(".excalidraw")) {
      return {
        type: "placeholder",
        icon: `<svg viewBox="0 0 100 100" class="ftp-file-icon"><path d="M20,50 Q35,20 50,50 T80,50" stroke="currentColor" stroke-width="3" fill="none" opacity="0.5"/><circle cx="30" cy="70" r="8" fill="currentColor" opacity="0.3"/><rect x="55" y="25" width="25" height="20" fill="none" stroke="currentColor" stroke-width="2" opacity="0.4"/></svg>`,
        label: "Excalidraw"
      };
    }
    if (ext === "pdf") {
      return {
        type: "placeholder",
        icon: `<svg viewBox="0 0 100 100" class="ftp-file-icon"><rect x="20" y="10" width="50" height="70" rx="3" fill="none" stroke="currentColor" stroke-width="3" opacity="0.5"/><line x1="30" y1="30" x2="60" y2="30" stroke="currentColor" stroke-width="2" opacity="0.3"/><line x1="30" y1="45" x2="60" y2="45" stroke="currentColor" stroke-width="2" opacity="0.3"/><line x1="30" y1="60" x2="50" y2="60" stroke="currentColor" stroke-width="2" opacity="0.3"/></svg>`,
        label: "PDF document"
      };
    }
    if (["mp3", "wav", "ogg", "m4a", "flac", "aac", "wma"].includes(ext)) {
      return {
        type: "placeholder",
        icon: `<svg viewBox="0 0 100 100" class="ftp-file-icon"><circle cx="35" cy="65" r="15" fill="none" stroke="currentColor" stroke-width="3" opacity="0.4"/><circle cx="65" cy="65" r="15" fill="none" stroke="currentColor" stroke-width="3" opacity="0.4"/><path d="M50,65 L50,25 L75,20 L75,60" stroke="currentColor" stroke-width="3" fill="none" opacity="0.5"/></svg>`,
        label: "Audio file"
      };
    }
    if (["mp4", "webm", "mov", "mkv", "avi", "wmv", "flv"].includes(ext)) {
      return {
        type: "placeholder",
        icon: `<svg viewBox="0 0 100 100" class="ftp-file-icon"><rect x="15" y="25" width="55" height="50" rx="3" fill="none" stroke="currentColor" stroke-width="3" opacity="0.4"/><polygon points="40,45 40,65 60,55" fill="currentColor" opacity="0.5"/></svg>`,
        label: "Video file"
      };
    }
    return null;
  }
  async renderFilePreview(file) {
    const fileTypeInfo = this.getFileTypeInfo(file);
    const isActive = this.activeFile === file;
    const classes = "ftp-preview-item" + (isActive ? " ftp-preview-item-active" : "");
    const previewItem = this.previewContent.createDiv({ cls: classes });
    previewItem.setAttribute("draggable", "true");
    previewItem.addEventListener("dragstart", (e) => {
      var _a;
      (_a = e.dataTransfer) == null ? void 0 : _a.setData("text/plain", file.path);
      if (e.dataTransfer) {
        e.dataTransfer.effectAllowed = "move";
      }
      this.dragGhost = document.body.createDiv({ cls: "ftp-drag-ghost" });
      this.dragGhost.setText(file.basename);
      const accentColor = getComputedStyle(document.body).getPropertyValue("--interactive-accent").trim();
      this.dragGhost.setCssProps({
        position: "fixed",
        left: "-9999px",
        top: "0",
        backgroundColor: `color-mix(in srgb, ${accentColor} 50%, transparent)`,
        color: getComputedStyle(document.body).getPropertyValue("--text-on-accent").trim()
      });
      if (e.dataTransfer) {
        e.dataTransfer.setDragImage(this.dragGhost, 50, 15);
      }
      previewItem.addClass("ftp-dragging");
    });
    previewItem.addEventListener("dragend", () => {
      previewItem.removeClass("ftp-dragging");
      if (this.dragGhost) {
        this.dragGhost.remove();
        this.dragGhost = null;
      }
    });
    const filename = previewItem.createDiv({ cls: "ftp-preview-filename" });
    filename.createEl("strong", { text: file.basename });
    if ((fileTypeInfo == null ? void 0 : fileTypeInfo.type) === "image") {
      const thumbnailContainer = previewItem.createDiv({ cls: "ftp-preview-thumbnail" });
      const img = thumbnailContainer.createEl("img");
      img.src = this.app.vault.getResourcePath(file);
      img.alt = file.basename;
      const lineCount = this.plugin.data.previewLines;
      thumbnailContainer.setCssProps({ height: `calc(1.4em * ${lineCount})` });
    } else if ((fileTypeInfo == null ? void 0 : fileTypeInfo.type) === "placeholder") {
      const placeholderContainer = previewItem.createDiv({ cls: "ftp-preview-placeholder" });
      const iconContainer = placeholderContainer.createDiv({ cls: "ftp-placeholder-icon" });
      const parser = new DOMParser();
      const doc = parser.parseFromString(fileTypeInfo.icon, "image/svg+xml");
      const svgEl = doc.documentElement;
      if (svgEl && !svgEl.querySelector("parsererror")) {
        iconContainer.appendChild(svgEl);
      }
      placeholderContainer.createDiv({ cls: "ftp-placeholder-label", text: fileTypeInfo.label });
      const lineCount = this.plugin.data.previewLines;
      placeholderContainer.setCssProps({ height: `calc(1.4em * ${lineCount})` });
    } else {
      const content = await this.app.vault.read(file);
      const previewText = this.extractPreviewText(content);
      const previewLines = previewItem.createDiv({ cls: "ftp-preview-lines" });
      previewLines.setText(previewText);
      const lineCount = this.plugin.data.previewLines;
      previewLines.setCssProps({
        "-webkit-line-clamp": lineCount.toString(),
        height: `calc(1.4em * ${lineCount})`
      });
    }
    previewItem.addEventListener("click", () => {
      const openFile = async () => {
        try {
          await this.app.workspace.getLeaf(false).openFile(file);
        } catch (error) {
          console.error("Error opening file:", error);
        }
      };
      openFile().catch(console.error);
    });
    previewItem.addEventListener("contextmenu", (e) => {
      e.preventDefault();
      const menu = new import_obsidian.Menu();
      menu.addItem((menuItem) => {
        menuItem.setTitle("New file").setIcon("document").onClick(() => {
          const createFile = async () => {
            const parentFolder = file.parent;
            if (!parentFolder)
              return;
            const fileName = "Untitled.md";
            let filePath = `${parentFolder.path}/${fileName}`;
            let counter = 1;
            while (await this.app.vault.adapter.exists(filePath)) {
              filePath = `${parentFolder.path}/Untitled ${counter}.md`;
              counter++;
            }
            const newFile = await this.app.vault.create(filePath, "");
            await this.app.workspace.getLeaf(false).openFile(newFile);
          };
          createFile().catch(console.error);
        });
      });
      menu.addItem((menuItem) => {
        menuItem.setTitle("New folder").setIcon("folder").onClick(() => {
          const createFolder = async () => {
            const parentFolder = file.parent;
            if (!parentFolder)
              return;
            const folderName = "New folder";
            let folderPath = `${parentFolder.path}/${folderName}`;
            let counter = 1;
            while (await this.app.vault.adapter.exists(folderPath)) {
              folderPath = `${parentFolder.path}/New folder ${counter}`;
              counter++;
            }
            await this.app.vault.createFolder(folderPath);
          };
          createFolder().catch(console.error);
        });
      });
      menu.addSeparator();
      menu.addItem((menuItem) => {
        menuItem.setTitle("Rename").setIcon("pencil").onClick(() => {
          new RenameModal(this.app, file.name, (newName) => {
            const renameFile = async () => {
              if (newName !== file.name) {
                const parentPath = file.parent ? file.parent.path : "";
                const newPath = parentPath ? `${parentPath}/${newName}` : newName;
                try {
                  await this.app.vault.rename(file, newPath);
                } catch (error) {
                  console.error("Failed to rename file:", error);
                }
              }
            };
            renameFile().catch(console.error);
          }).open();
        });
      });
      menu.addItem((menuItem) => {
        menuItem.setTitle("Duplicate").setIcon("copy").onClick(() => {
          const duplicateFile = async () => {
            const parentFolder = file.parent;
            if (!parentFolder)
              return;
            const content = await this.app.vault.read(file);
            const baseName = file.basename;
            const extension = file.extension;
            let duplicateName = `${baseName} copy`;
            let duplicatePath = `${parentFolder.path}/${duplicateName}.${extension}`;
            let counter = 1;
            while (await this.app.vault.adapter.exists(duplicatePath)) {
              duplicateName = `${baseName} copy ${counter}`;
              duplicatePath = `${parentFolder.path}/${duplicateName}.${extension}`;
              counter++;
            }
            const newFile = await this.app.vault.create(duplicatePath, content);
            await this.app.workspace.getLeaf(false).openFile(newFile);
            this.renderPreview().catch(console.error);
          };
          duplicateFile().catch(console.error);
        });
      });
      menu.addItem((menuItem) => {
        menuItem.setTitle("Delete").setIcon("trash").onClick(() => {
          const deleteFile = async () => {
            try {
              await this.app.fileManager.trashFile(file);
              this.renderPreview().catch(console.error);
            } catch (error) {
              console.error("Failed to delete file:", error);
            }
          };
          deleteFile().catch(console.error);
        });
      });
      menu.addSeparator();
      this.app.workspace.trigger("file-menu", menu, file, "file-explorer");
      menu.showAtMouseEvent(e);
    });
  }
  extractPreviewText(content) {
    let text = content.trim();
    if (text.startsWith("---")) {
      const lines2 = text.split("\n");
      let endIndex = -1;
      for (let i = 1; i < lines2.length; i++) {
        if (lines2[i].trim() === "---") {
          endIndex = i;
          break;
        }
      }
      if (endIndex !== -1) {
        text = lines2.slice(endIndex + 1).join("\n").trim();
      }
    }
    text = text.replace(/^[\w-]+::.+$/gm, "");
    text = text.replace(/^\|?[\s|\-:]+\|?\s*$/gm, "");
    text = text.replace(/^#+\s/gm, "").replace(/\*\*(.+?)\*\*/g, "$1").replace(/\*(.+?)\*/g, "$1").replace(/^[>\-*+]\s/gm, "").replace(/\|/g, " ");
    if (this.plugin.data.removeLinkBrackets) {
      text = text.replace(/\[\[(.+?)\]\]/g, "$1").replace(/\[(.+?)\]\(.+?\)/g, "$1");
    }
    text = text.trim();
    const lines = text.split("\n").filter((line) => line.trim().length > 0);
    return lines.join(" ");
  }
};
var RenameModal = class extends import_obsidian.Modal {
  constructor(app, oldName, onSubmit) {
    super(app);
    this.oldName = oldName;
    this.onSubmit = onSubmit;
  }
  onOpen() {
    const { contentEl } = this;
    contentEl.empty();
    contentEl.createEl("h3", { text: "Rename" });
    const inputEl = contentEl.createEl("input", {
      type: "text",
      value: this.oldName,
      cls: "ftp-rename-input"
    });
    const dotIndex = this.oldName.lastIndexOf(".");
    if (dotIndex > 0) {
      inputEl.setSelectionRange(0, dotIndex);
    } else {
      inputEl.select();
    }
    const buttonContainer = contentEl.createDiv({ cls: "ftp-button-container" });
    const cancelButton = buttonContainer.createEl("button", { text: "Cancel" });
    cancelButton.addEventListener("click", () => this.close());
    const submitButton = buttonContainer.createEl("button", { text: "Rename", cls: "mod-cta" });
    submitButton.addEventListener("click", () => {
      const newName = inputEl.value.trim();
      if (newName && newName !== this.oldName) {
        this.onSubmit(newName);
      }
      this.close();
    });
    inputEl.addEventListener("keypress", (e) => {
      if (e.key === "Enter") {
        submitButton.click();
      }
    });
    inputEl.focus();
  }
  onClose() {
    const { contentEl } = this;
    contentEl.empty();
  }
};
var DeleteFolderModal = class extends import_obsidian.Modal {
  constructor(app, folderName, onConfirm) {
    super(app);
    this.folderName = folderName;
    this.onConfirm = onConfirm;
  }
  onOpen() {
    const { contentEl } = this;
    contentEl.empty();
    contentEl.createEl("h3", { text: "Delete folder" });
    const warningEl = contentEl.createDiv({ cls: "ftp-delete-warning" });
    warningEl.createEl("p", {
      text: `Are you sure you want to delete "${this.folderName}"?`
    });
    const detailEl = contentEl.createEl("p", {
      text: "This will delete the folder and all of its contents (files and subfolders). This action cannot be undone.",
      cls: "ftp-delete-detail"
    });
    const buttonContainer = contentEl.createDiv({ cls: "ftp-button-container" });
    buttonContainer.setCssProps({ marginTop: "20px" });
    const cancelButton = buttonContainer.createEl("button", { text: "Cancel" });
    cancelButton.addEventListener("click", () => this.close());
    const deleteButton = buttonContainer.createEl("button", { text: "Delete", cls: "mod-warning" });
    deleteButton.addEventListener("click", () => {
      this.onConfirm();
      this.close();
    });
    cancelButton.focus();
  }
  onClose() {
    const { contentEl } = this;
    contentEl.empty();
  }
};
var FileTreePreviewSettingTab = class extends import_obsidian.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.plugin = plugin;
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    new import_obsidian.Setting(containerEl).setHeading().setName("File Tree Preview settings");
    new import_obsidian.Setting(containerEl).setName("Active on launch").setDesc("Automatically open File Tree Preview when Obsidian starts").addToggle((toggle) => toggle.setValue(this.plugin.data.activeOnLaunch).onChange(async (value) => {
      this.plugin.data.activeOnLaunch = value;
      await this.plugin.savePluginData();
    }));
    new import_obsidian.Setting(containerEl).setName("Compact mode").setDesc("Reduce spacing throughout for a denser view").addToggle((toggle) => toggle.setValue(this.plugin.data.compactMode).onChange(async (value) => {
      this.plugin.data.compactMode = value;
      await this.plugin.savePluginData();
      this.app.workspace.getLeavesOfType(VIEW_TYPE_FILE_TREE_PREVIEW).forEach((leaf) => {
        if (leaf.view instanceof FileTreePreviewView) {
          leaf.view.setCompactMode(value);
        }
      });
    }));
    new import_obsidian.Setting(containerEl).setName("Use accent color for active file").setDesc("Highlight the active file with your accent color. When disabled, uses a neutral gray.").addToggle((toggle) => toggle.setValue(this.plugin.data.useAccentColor).onChange(async (value) => {
      this.plugin.data.useAccentColor = value;
      await this.plugin.savePluginData();
      this.app.workspace.getLeavesOfType(VIEW_TYPE_FILE_TREE_PREVIEW).forEach((leaf) => {
        if (leaf.view instanceof FileTreePreviewView) {
          leaf.view.setHighlightColor(value);
        }
      });
    }));
    new import_obsidian.Setting(containerEl).setName("Show hover effect").setDesc("Show background color when hovering over folders and preview cards").addToggle((toggle) => toggle.setValue(this.plugin.data.showHoverEffect).onChange(async (value) => {
      this.plugin.data.showHoverEffect = value;
      await this.plugin.savePluginData();
      this.app.workspace.getLeavesOfType(VIEW_TYPE_FILE_TREE_PREVIEW).forEach((leaf) => {
        if (leaf.view instanceof FileTreePreviewView) {
          leaf.view.setHoverEffect(value);
        }
      });
    }));
    new import_obsidian.Setting(containerEl).setName("Folder icons").setDesc("Choose how to display folder icons in the folder tree").addDropdown((dropdown) => dropdown.addOption("none", "No icons").addOption("custom", "Custom icons").addOption("folder", "Folder emoji (\u{1F4C1})").setValue(this.plugin.data.folderIconStyle).onChange(async (value) => {
      this.plugin.data.folderIconStyle = value;
      await this.plugin.savePluginData();
      this.app.workspace.getLeavesOfType(VIEW_TYPE_FILE_TREE_PREVIEW).forEach((leaf) => {
        if (leaf.view instanceof FileTreePreviewView) {
          leaf.view.renderFileTree().catch(console.error);
        }
      });
    }));
    new import_obsidian.Setting(containerEl).setName("Preview lines").setDesc("Number of lines to show in each file preview card (1-10)").addSlider((slider) => slider.setLimits(1, 10, 1).setValue(this.plugin.data.previewLines).setDynamicTooltip().onChange(async (value) => {
      this.plugin.data.previewLines = value;
      await this.plugin.savePluginData();
      this.app.workspace.getLeavesOfType(VIEW_TYPE_FILE_TREE_PREVIEW).forEach((leaf) => {
        if (leaf.view instanceof FileTreePreviewView) {
          leaf.view.renderPreview().catch(console.error);
        }
      });
    }));
    new import_obsidian.Setting(containerEl).setName("Remove link brackets").setDesc("Remove brackets from wiki-links ([[link]]) and markdown links ([text](url)) in preview text").addToggle((toggle) => toggle.setValue(this.plugin.data.removeLinkBrackets).onChange(async (value) => {
      this.plugin.data.removeLinkBrackets = value;
      await this.plugin.savePluginData();
      this.app.workspace.getLeavesOfType(VIEW_TYPE_FILE_TREE_PREVIEW).forEach((leaf) => {
        if (leaf.view instanceof FileTreePreviewView) {
          leaf.view.renderPreview().catch(console.error);
        }
      });
    }));
    const kofiContainer = containerEl.createDiv({ cls: "ftp-kofi-container" });
    const kofiText = kofiContainer.createEl("p", {
      text: "If you find this plugin helpful, consider ",
      cls: "ftp-kofi-text"
    });
    const kofiLink = kofiText.createEl("a", {
      text: "buying me a coffee",
      href: "https://ko-fi.com/J3J61ODQ3A",
      cls: "ftp-kofi-link"
    });
    kofiLink.setAttribute("target", "_blank");
    kofiText.appendText(" \u2615");
  }
};
